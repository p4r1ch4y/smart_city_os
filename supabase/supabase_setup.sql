-- Smart City OS - Improved Supabase Schema (announcements, sensors, alerts, telemetry, blockchain)
-- Run this in Supabase SQL editor. Idempotent (IF NOT EXISTS used where possible).

-- Extensions
create extension if not exists "pgcrypto";

-- =============================
-- 1) Announcements (City Notices)
-- =============================
create table if not exists public.announcements (
  id bigint generated by default as identity primary key,
  title text not null,
  content text not null,
  image_url text,
  video_url text,
  link_url text,
  author text not null,
  created_at timestamptz not null default now()
);

alter table public.announcements enable row level security;

drop policy if exists "announcements_select_auth" on public.announcements;
create policy "announcements_select_auth" on public.announcements
  for select to authenticated using (true);

drop policy if exists "announcements_insert_auth" on public.announcements;
create policy "announcements_insert_auth" on public.announcements
  for insert to authenticated with check (true);

drop policy if exists "announcements_update_self" on public.announcements;
create policy "announcements_update_self" on public.announcements
  for update to authenticated using (author = (auth.jwt() ->> 'email')) with check (author = (auth.jwt() ->> 'email'));

drop policy if exists "announcements_delete_self" on public.announcements;
create policy "announcements_delete_self" on public.announcements
  for delete to authenticated using (author = (auth.jwt() ->> 'email'));

create index if not exists announcements_created_at_idx on public.announcements (created_at desc);

-- =============================
-- 2) Sensors and Telemetry
-- =============================
create table if not exists public.sensors (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  type text not null, -- e.g., traffic, air_quality, energy, water, waste
  location text,
  city text,
  latitude double precision,
  longitude double precision,
  status text default 'active', -- active/inactive
  last_reading timestamptz,
  value numeric,
  metadata jsonb default '{}',
  created_at timestamptz not null default now()
);

alter table public.sensors enable row level security;

drop policy if exists "sensors_select_auth" on public.sensors;
create policy "sensors_select_auth" on public.sensors
  for select to authenticated using (true);

drop policy if exists "sensors_insert_auth" on public.sensors;
create policy "sensors_insert_auth" on public.sensors
  for insert to authenticated with check (true);

drop policy if exists "sensors_update_auth" on public.sensors;
create policy "sensors_update_auth" on public.sensors
  for update to authenticated using (true) with check (true);

drop policy if exists "sensors_delete_auth" on public.sensors;
create policy "sensors_delete_auth" on public.sensors
  for delete to authenticated using (true);

create index if not exists sensors_city_idx on public.sensors (city);
create index if not exists sensors_type_idx on public.sensors (type);
create index if not exists sensors_created_at_idx on public.sensors (created_at desc);

create table if not exists public.sensor_data (
  id bigserial primary key,
  sensor_id uuid not null references public.sensors(id) on delete cascade,
  value numeric not null,
  unit text default 'units',
  timestamp timestamptz not null default now(),
  metadata jsonb default '{}'
);

alter table public.sensor_data enable row level security;

drop policy if exists "sensor_data_select_auth" on public.sensor_data;
create policy "sensor_data_select_auth" on public.sensor_data
  for select to authenticated using (true);

drop policy if exists "sensor_data_insert_auth" on public.sensor_data;
create policy "sensor_data_insert_auth" on public.sensor_data
  for insert to authenticated with check (true);

create index if not exists sensor_data_sensor_ts_idx on public.sensor_data (sensor_id, timestamp desc);

-- =============================
-- 3) Alerts
-- =============================
create table if not exists public.alerts (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  message text not null,
  type text not null, -- traffic, air_quality, etc.
  severity text not null default 'medium', -- low/medium/high/critical
  status text not null default 'open', -- open/acknowledged/resolved
  sensor_id uuid references public.sensors(id) on delete set null,
  location text,
  acknowledged_at timestamptz,
  resolved_at timestamptz,
  metadata jsonb default '{}',
  created_at timestamptz not null default now()
);

alter table public.alerts enable row level security;

drop policy if exists "alerts_select_auth" on public.alerts;
create policy "alerts_select_auth" on public.alerts
  for select to authenticated using (true);

drop policy if exists "alerts_insert_auth" on public.alerts;
create policy "alerts_insert_auth" on public.alerts
  for insert to authenticated with check (true);

drop policy if exists "alerts_update_auth" on public.alerts;
create policy "alerts_update_auth" on public.alerts
  for update to authenticated using (true) with check (true);

drop policy if exists "alerts_delete_auth" on public.alerts;
create policy "alerts_delete_auth" on public.alerts
  for delete to authenticated using (true);

create index if not exists alerts_created_at_idx on public.alerts (created_at desc);
create index if not exists alerts_severity_idx on public.alerts (severity);
create index if not exists alerts_status_idx on public.alerts (status);

-- =============================
-- 4) Air Quality (optional analytics convenience)
-- =============================
create table if not exists public.air_quality (
  id uuid primary key default gen_random_uuid(),
  sensor_id uuid references public.sensors(id) on delete set null,
  aqi integer,
  pm25 numeric,
  pm10 numeric,
  no2 numeric,
  so2 numeric,
  co numeric,
  o3 numeric,
  recorded_at timestamptz not null default now(),
  created_at timestamptz not null default now()
);

alter table public.air_quality enable row level security;
drop policy if exists "air_quality_select_auth" on public.air_quality;
create policy "air_quality_select_auth" on public.air_quality for select to authenticated using (true);
create index if not exists air_quality_sensor_time_idx on public.air_quality (sensor_id, recorded_at desc);

-- =============================
-- 5) Blockchain (optional logging)
-- =============================
create table if not exists public.contracts (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  address text not null,
  network text not null,
  metadata jsonb default '{}',
  created_at timestamptz not null default now()
);

alter table public.contracts enable row level security;
drop policy if exists "contracts_select_auth" on public.contracts;
create policy "contracts_select_auth" on public.contracts for select to authenticated using (true);

create table if not exists public.blockchain_transactions (
  id uuid primary key default gen_random_uuid(),
  contract_id uuid references public.contracts(id) on delete set null,
  tx_id text not null,
  status text not null default 'pending',
  data_hash text,
  details jsonb default '{}',
  created_at timestamptz not null default now()
);

alter table public.blockchain_transactions enable row level security;
drop policy if exists "blockchain_tx_select_auth" on public.blockchain_transactions;
create policy "blockchain_tx_select_auth" on public.blockchain_transactions for select to authenticated using (true);
create index if not exists blockchain_tx_created_idx on public.blockchain_transactions (created_at desc);

-- =============================
-- 6) (Optional) User profiles with role
-- =============================
create table if not exists public.user_profiles (
  id uuid primary key default gen_random_uuid(),
  auth_user_id uuid not null unique, -- maps to auth.users.id
  email text not null unique,
  full_name text,
  role text default 'citizen', -- citizen/admin
  metadata jsonb default '{}',
  created_at timestamptz not null default now()
);

alter table public.user_profiles enable row level security;
drop policy if exists "user_profiles_select_self" on public.user_profiles;
create policy "user_profiles_select_self" on public.user_profiles
  for select to authenticated using (auth.uid() = auth_user_id);

drop policy if exists "user_profiles_upsert_self" on public.user_profiles;
create policy "user_profiles_upsert_self" on public.user_profiles
  for insert to authenticated with check (auth.uid() = auth_user_id);

drop policy if exists "user_profiles_update_self" on public.user_profiles;
create policy "user_profiles_update_self" on public.user_profiles
  for update to authenticated using (auth.uid() = auth_user_id) with check (auth.uid() = auth_user_id);

-- Helpful views or defaults can be added here as needed.

